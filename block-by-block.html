<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>One-Minute Concert Band (Real Instruments)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  body { font-family: system-ui, Arial, sans-serif; line-height: 1.4; padding: 24px; }
  h1 { margin-bottom: 0.25rem; }
  .small { color: #555; margin-top: 0; }
  button { padding: 10px 16px; font-size: 16px; cursor: pointer; }
  #status { margin-top: 10px; color: #2a6; }
  #err { margin-top: 10px; color: #a22; white-space: pre-wrap; }
  .inst { margin-top: 16px; }
</style>
</head>
<body>
  <h1>ðŸŽ¶ One-Minute Concert Band</h1>
  <p class="small">Features common band instruments with realistic samples. Click play and let it ride for exactly 60 seconds.</p>
  <button id="playBtn">Play</button>
  <div id="status"></div>
  <div id="err"></div>
  <div class="inst">
    <strong>Instruments:</strong> Flute, Clarinet, Oboe, Bassoon, Alto Sax, Trumpet, Trombone, French Horn, Tuba, Piano, Acoustic Bass, Glockenspiel, Xylophone, Timpani.
  </div>

  <!-- Soundfont Player (FluidR3 samples hosted via unpkg) -->
  <script src="https://unpkg.com/soundfont-player@0.15.7/dist/soundfont-player.js"></script>
  <script>
  // â€”â€”â€” Config â€”â€”â€”
  const BPM = 120;                 // 120 BPM => 0.5s per beat
  const BEAT = 60 / BPM;           // seconds per beat
  const BAR = BEAT * 4;            // 4/4 time
  const TOTAL_BARS = 30;           // 30 bars * 2s per bar = 60s
  const MASTER_GAIN = 0.9;         // master volume scaling

  // GM instrument names (FluidR3) to load
  const INSTRUMENTS = {
    flute: 'flute',
    clarinet: 'clarinet',
    oboe: 'oboe',
    bassoon: 'bassoon',
    altoSax: 'alto_sax',
    trumpet: 'trumpet',
    trombone: 'trombone',
    horn: 'french_horn',
    tuba: 'tuba',
    piano: 'acoustic_grand_piano',
    bass: 'acoustic_bass',
    glock: 'glockenspiel',
    xylo: 'xylophone',
    timp: 'timpani'
  };

  const stateEl = document.getElementById('status');
  const errEl = document.getElementById('err');
  const playBtn = document.getElementById('playBtn');

  let ac;
  let loaded = {};
  let started = false;

  function setStatus(msg) { stateEl.textContent = msg; }
  function setError(msg) { errEl.textContent = msg; }

  // â€”â€”â€” Musical helpers â€”â€”â€”
  function transpose(note, semitones) {
    // Simple transposition on scientific pitch names, e.g., C4 -> D#4
    const order = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
    const m = note.match(/^([A-G]#?)(-?\d)$/);
    if (!m) return note;
    const idx = order.indexOf(m[1]);
    const octave = parseInt(m[2], 10);
    let n = idx + semitones;
    let newOct = octave + Math.floor(n / 12);
    n = ((n % 12) + 12) % 12;
    return order[n] + newOct;
  }

  // Build a diatonic scale in G major for easy melodic writing
  const SCALE_G = ['G','A','B','C','D','E','F#'];
  function scaleDegree(deg, octave=4) {
    const name = SCALE_G[(deg - 1) % 7];
    const addOct = Math.floor((deg - 1) / 7);
    return name + (octave + addOct);
  }

  function chord(root, type='maj', octave=3) {
    // Triads: maj/min
    const map = { maj: [0,4,7], min: [0,3,7] };
    const semis = map[type];
    return semis.map(s => transpose(root + octave, s));
  }

  // Progression: G â€“ Em â€“ C â€“ D (Iâ€“viâ€“IVâ€“V)
  const PROG = [
    {root:'G', type:'maj'},
    {root:'E', type:'min'},
    {root:'C', type:'maj'},
    {root:'D', type:'maj'}
  ];

  function scheduleNote(inst, note, when, dur, gain=1.0) {
    if (!inst) return;
    inst.play(note, ac.currentTime + when, { gain: gain * MASTER_GAIN, duration: dur });
  }

  function rotate(arr, bars) {
    return arr[bars % arr.length];
  }

  // â€”â€”â€” Arrangement (60 seconds total) â€”â€”â€”
  function scheduleSong() {
    const startAt = ac.currentTime + 0.1;

    // Rhythm guide (piano light staccato)
    for (let bar = 0; bar < TOTAL_BARS; bar++) {
      const t = (bar * BAR);
      const chordInfo = PROG[bar % PROG.length];
      const root = chordInfo.root;
      // Piano: chord stabs on beats 1 & 3
      const triad = chord(root, chordInfo.type, 4);
      [0, 2].forEach(beat => {
        triad.forEach((n, i) => {
          loaded.piano.play(n, startAt + t + beat*BEAT + i*0.01, { gain: 0.08, duration: 0.22 });
        });
      });
    }

    // Low end: Tuba + Acoustic Bass alternating
    for (let bar = 0; bar < TOTAL_BARS; bar++) {
      const t = bar * BAR;
      const chordInfo = PROG[bar % PROG.length];
      const root = chordInfo.root + 2; // e.g., G2
      const isEven = bar % 2 === 0;
      const inst = isEven ? loaded.tuba : loaded.bass;
      // Pattern: beat 1 (root), beat 3 (fifth)
      inst.play(root, startAt + t + 0*BEAT, { gain: 0.18, duration: 0.35 });
      const fifth = transpose(root, 7);
      inst.play(fifth, startAt + t + 2*BEAT, { gain: 0.16, duration: 0.35 });
    }

    // Horns & Trombones: backbeat swells on beats 2 & 4
    for (let bar = 0; bar < TOTAL_BARS; bar++) {
      const t = bar * BAR;
      const chordInfo = PROG[bar % PROG.length];
      const triad3 = chord(chordInfo.root, chordInfo.type, 3);
      [1, 3].forEach(beat => {
        triad3.forEach(n => {
          loaded.horn.play(n, startAt + t + beat*BEAT, { gain: 0.14, duration: 0.45 });
          loaded.trombone.play(n, startAt + t + beat*BEAT + 0.02, { gain: 0.14, duration: 0.45 });
        });
      });
    }

    // Percussive color: Glock + Xylo on offbeats
    for (let bar = 0; bar < TOTAL_BARS; bar++) {
      const t = bar * BAR;
      const chordInfo = PROG[bar % PROG.length];
      const triad5 = chord(chordInfo.root, chordInfo.type, 5);
      [0.5, 1.5, 2.5, 3.5].forEach(off => {
        loaded.glock.play(triad5[0], startAt + t + off*BEAT, { gain: 0.1, duration: 0.18 });
        loaded.xylo.play(triad5[1], startAt + t + off*BEAT + 0.02, { gain: 0.1, duration: 0.18 });
      });
    }

    // Timpani hits marking phrase starts
    for (let bar = 0; bar < TOTAL_BARS; bar += 2) {
      const t = bar * BAR;
      const chordInfo = PROG[bar % PROG.length];
      loaded.timp.play(chordInfo.root + '2', startAt + t, { gain: 0.22, duration: 0.6 });
    }

    // Woodwind melody (8-bar sections, passes between instruments)
    const melodyPhrases = [
      // Phrase A (bars 0â€“7): G major motif
      [ 'G5','A5','B5','D5','B5','A5','G5', null,  'A5','B5','C6','E5','C6','B5','A5', null ],
      // Phrase B (bars 8â€“15)
      [ 'B5','C6','D6','F#5','D6','C6','B5', null, 'C6','D6','E6','G5','E6','D6','C6', null ],
      // Phrase C (bars 16â€“23)
      [ 'D6','E6','F#6','A5','F#6','E6','D6', null, 'E6','F#6','G6','B5','G6','F#6','E6', null ],
      // Phrase D (bars 24â€“29 shortened to 6 bars, repeats cadence)
      [ 'B5','A5','G5','D6','C6','B5','A5','G5', 'A5','G5','D5','G5','â€”','â€”','â€”','â€”' ]
    ];
    const wws = [loaded.flute, loaded.clarinet, loaded.oboe, loaded.altoSax];

    let barPointer = 0;
    for (let p = 0; p < melodyPhrases.length; p++) {
      const phrase = melodyPhrases[p];
      const lead = wws[p % wws.length];
      for (let i = 0; i < phrase.length && barPointer < TOTAL_BARS; i++) {
        const n = phrase[i];
        const t = barPointer * BAR;
        if (n && n !== 'â€”' && lead) {
          // Eighth-note pickup pattern on beats 1&a, 2&a, etc.
          lead.play(n, startAt + t + 0.0*BEAT, { gain: 0.16, duration: 0.35 });
        }
        barPointer++;
      }
    }

    // Brass countermelody (trumpet feature alternates with clarinet)
    for (let bar = 4; bar < TOTAL_BARS; bar++) {
      const t = bar * BAR;
      const d1 = scaleDegree(5, 5); // D5 (dominant)
      const d2 = scaleDegree(3, 5); // B4/5 area depending on octave setting
      const lead = (bar % 8 < 4) ? loaded.trumpet : loaded.clarinet;
      if (lead) {
        lead.play(d1, startAt + t + 1*BEAT, { gain: 0.14, duration: 0.25 });
        lead.play(d2, startAt + t + 1.5*BEAT, { gain: 0.14, duration: 0.25 });
        lead.play(transpose(d1, 2), startAt + t + 3*BEAT, { gain: 0.14, duration: 0.25 });
      }
    }

    // Bassoon line shadowing the bass on beat 1 (adds reed color)
    for (let bar = 0; bar < TOTAL_BARS; bar++) {
      const t = bar * BAR;
      const root = PROG[bar % PROG.length].root + '3';
      loaded.bassoon.play(root, startAt + t, { gain: 0.12, duration: 0.4 });
    }

    // Closing cadence (last 2 bars): tutti hits + glock tag
    const endBar = TOTAL_BARS - 2;
    const tEnd = endBar * BAR;
    const endingRoot = 'G';
    const hitNotes = [
      endingRoot+'4', endingRoot+'3', endingRoot+'5'
    ];
    [loaded.horn, loaded.trombone, loaded.trumpet, loaded.clarinet, loaded.altoSax, loaded.oboe].forEach(inst => {
      hitNotes.forEach((n, i) => inst.play(n, startAt + tEnd + i*0.05, { gain: 0.16, duration: 0.6 }));
    });
    loaded.piano.play(endingRoot+'2', startAt + tEnd, { gain: 0.18, duration: 0.8 });
    loaded.tuba.play(endingRoot+'2', startAt + tEnd, { gain: 0.2, duration: 0.8 });
    loaded.timp.play(endingRoot+'2', startAt + tEnd, { gain: 0.22, duration: 0.8 });
    // Glockenspiel tag
    ['D6','E6','F#6','G6'].forEach((n, i) => {
      loaded.glock.play(n, startAt + tEnd + 1.0 + i*0.12, { gain: 0.12, duration: 0.25 });
    });

    // Stop message at exactly 60s
    setTimeout(() => setStatus('Done. Replay if youâ€™d like!'), 60000);
  }

  // â€”â€”â€” Boot & Play â€”â€”â€”
  async function loadInstruments() {
    setStatus('Loading instruments...');
    const names = Object.values(INSTRUMENTS);
    const keys = Object.keys(INSTRUMENTS);
    const loaders = names.map(n => Soundfont.instrument(ac, n, { gain: 0.9 }));
    const res = await Promise.all(loaders);
    keys.forEach((k, i) => loaded[k] = res[i]);
    setStatus('Ready. Playing...');
  }

  playBtn.addEventListener('click', async () => {
    try {
      if (!started) {
        ac = new (window.AudioContext || window.webkitAudioContext)();
        started = true;
        await loadInstruments();
      } else {
        setStatus('Playing...');
      }
      scheduleSong();
    } catch (e) {
      setError('Error: ' + (e && e.message ? e.message : String(e)));
    }
  });
  </script>
</body>
</html>
